import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.math.BigInteger;
import java.util.Arrays;
import java.util.HashMap;
import java.util.StringTokenizer;

public class SquaredSubsequence {

	static private PrintWriter out=new PrintWriter(System.out);
	static public void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		int t=Integer.parseInt(br.readLine());


		while(t-->0){
			solve(br);	
		}

		out.flush();
		out.close();
	}
	private static void solve(BufferedReader br) throws Exception{
		// TODO Auto-generated method stub

		int n=Integer.parseInt(br.readLine());
		int arr[]=new int[n];
		long ans=0;
		BigInteger biTwo=BigInteger.valueOf(2);
		BigInteger biFour=BigInteger.valueOf(4);
		BigInteger biZero=BigInteger.ZERO;

		StringTokenizer st=new StringTokenizer(br.readLine());
		for(int i=0;i<n;i++){
			int num=Integer.parseInt(st.nextToken());
			
			if(num%2==0){
				if(num%4==0)
				arr[i]=4;
				else
				arr[i]=2;	
			}else{
				arr[i]=0;
			}
			
			out.print(arr[i]+" ");
		}
         out.println();
		
		ans=findSubarraySum(arr, n,0);
		//out.println("1st0 "+ans);
		ans+=findCnt(arr, n, 3);
		//out.println("2nd4 "+ans);

		
		out.println("ans"+ans);

	}
	
	
	 static int findSubarraySum(int arr[], int n,int sum)  
	    {  
	        // HashMap to store number of subarrays  
	        // starting from index zero having   
	        // particular value of sum.  
	        HashMap <Integer, Integer> prevSum = new HashMap<>();  
	        
	        int res = 0;  
	        
	        // Sum of elements so far.  
	        int currsum = 0;  
	        
	        for (int i = 0; i < n; i++) {  
	        
	            // Add current element to sum so far.  
	            currsum += arr[i];  
	        
	            // If currsum is equal to desired sum,  
	            // then a new subarray is found. So  
	            // increase count of subarrays.  
	            if (currsum ==sum)   
	                res++;          
	        
	            // currsum exceeds given sum by currsum   
	            //  - sum. Find number of subarrays having   
	            // this sum and exclude those subarrays  
	            // from currsum by increasing count by   
	            // same amount.  
	            if (prevSum.containsKey(currsum - sum))   
	                res += prevSum.get(currsum - sum);  
	                
	        
	            // Add currsum value to count of   
	            // different values of sum.  
	            Integer count = prevSum.get(currsum); 
	            if (count == null) 
	                prevSum.put(currsum, 1); 
	            else
	                prevSum.put(currsum, count+1);  
	        }  
	        
	        return res;  
	    }
	 static int findCnt(int arr[], int n, int k) 
	 { 
	     // Variable to store final answer 
	     int ans = 0; 
	   
	     // Loop to find prefix-sum 
	     for (int i = 1; i < n; i++) 
	     { 
	         arr[i] += arr[i - 1]; 
	         if (arr[i] > k || arr[i] < -1 * k) 
	             ans++; 
	     } 
	   
	     if (arr[0] > k || arr[0] < -1 * k) 
	         ans++; 
	   
	     // Sorting prefix-sum array 
	     Arrays.sort(arr); 
	   
	     // Loop to find upper_bound 
	     // for each element 
	     for (int i = 0; i < n; i++) 
	         ans += n - upper_bound(arr, 0, n, arr[i] + k); 
	   
	     // Returning final answer 
	     return ans; 
	 } 
	   
	 static int upper_bound(int[] a, int low,  
	                     int high, int element) 
	 { 
	     while(low < high) 
	     { 
	         int middle = low + (high - low)/2; 
	         if(a[middle] > element) 
	             high = middle; 
	         else
	             low = middle + 1; 
	     } 
	     return low; 
	 }
}
